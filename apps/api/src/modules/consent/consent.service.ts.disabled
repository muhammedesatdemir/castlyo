import { Injectable, ForbiddenException, NotFoundException } from '@nestjs/common';
import { eq, and } from 'drizzle-orm';
import { db } from '@castlyo/database';
import { consentLogs, userConsents, contactPermissions, users } from '@castlyo/database';
import { AuditService } from '../permissions/audit.service';

export interface UpdateConsentRequest {
  userId: string;
  consentType: 'marketing' | 'dataSharing' | 'communication';
  granted: boolean;
  ipAddress?: string;
  userAgent?: string;
}

export interface ConsentWithdrawalPolicy {
  consentType: string;
  canWithdraw: boolean;
  reason?: string;
  affectedServices: string[];
}

@Injectable()
export class ConsentService {
  constructor(private auditService: AuditService) {}

  /**
   * Update user consent
   */
  async updateConsent(request: UpdateConsentRequest) {
    // Check if consent type can be withdrawn
    const policy = this.getConsentWithdrawalPolicy(request.consentType);
    
    if (!request.granted && !policy.canWithdraw) {
      throw new ForbiddenException(policy.reason || 'This consent cannot be withdrawn');
    }

    // Get or create user consents record
    let userConsent = await db.select()
      .from(userConsents)
      .where(eq(userConsents.userId, request.userId))
      .limit(1);

    if (userConsent.length === 0) {
      // Create new consent record
      await db.insert(userConsents).values({
        userId: request.userId,
        [request.consentType]: request.granted,
      });
    } else {
      // Update existing consent record
      await db.update(userConsents)
        .set({
          [request.consentType]: request.granted,
          updatedAt: new Date(),
        })
        .where(eq(userConsents.userId, request.userId));
    }

    // Log the consent change
    const consentLog = await db.insert(consentLogs).values({
      userId: request.userId,
      userRole: 'USER', // TODO: Get actual user role
      action: request.granted ? 'CONSENT_GRANTED' : 'CONSENT_REVOKED',
      resource: 'USER_CONSENT',
      resourceId: request.userId,
      details: `${request.consentType} consent ${request.granted ? 'granted' : 'revoked'}`,
    }).returning();

    // Log audit event
    await this.auditService.log({
      userId: request.userId,
      userRole: 'TALENT', // TODO: Get actual role
      action: request.granted ? 'CONSENT_GRANTED' : 'CONSENT_REVOKED',
      resource: 'USER_CONSENT',
      resourceId: request.userId,
      details: JSON.stringify({
        consentType: request.consentType,
        previousState: !request.granted,
        newState: request.granted,
        policy: policy,
      }),
      ipAddress: request.ipAddress,
      userAgent: request.userAgent,
    });

    // Handle side effects of consent withdrawal
    if (!request.granted) {
      await this.handleConsentWithdrawalSideEffects(request.userId, request.consentType);
    }

    return {
      success: true,
      consentLog: consentLog[0],
      policy,
    };
  }

  /**
   * Get consent withdrawal policy for a specific consent type
   */
  private getConsentWithdrawalPolicy(consentType: string): ConsentWithdrawalPolicy {
    const policies: Record<string, ConsentWithdrawalPolicy> = {
      KVKK: {
        consentType: 'KVKK',
        canWithdraw: false,
        reason: 'KVKK consent is required for platform usage. Please contact support to delete your account.',
        affectedServices: ['platform_usage'],
      },
      MARKETING: {
        consentType: 'MARKETING',
        canWithdraw: true,
        affectedServices: ['email_marketing', 'sms_marketing'],
      },
      COMMUNICATION: {
        consentType: 'COMMUNICATION',
        canWithdraw: true,
        affectedServices: ['job_notifications', 'platform_updates'],
      },
      DATA_SHARING: {
        consentType: 'DATA_SHARING',
        canWithdraw: true,
        affectedServices: ['profile_visibility', 'new_contact_permissions'],
      },
    };

    return policies[consentType] || {
      consentType,
      canWithdraw: false,
      reason: 'Unknown consent type',
      affectedServices: [],
    };
  }

  /**
   * Handle side effects when consent is withdrawn
   */
  private async handleConsentWithdrawalSideEffects(userId: string, consentType: string) {
    switch (consentType) {
      case 'DATA_SHARING':
        // When data sharing consent is withdrawn:
        // 1. Existing contact permissions remain valid (they were granted with explicit consent)
        // 2. But no NEW contact permissions can be granted
        // 3. Profile visibility might be restricted
        
        await this.auditService.log({
          userId,
          userRole: 'TALENT',
          action: 'DATA_SHARING_RESTRICTED',
          resource: 'USER_PROFILE',
          resourceId: userId,
          details: JSON.stringify({
            restriction: 'new_contact_permissions_blocked',
            existingPermissions: 'remain_valid',
            note: 'User withdrew data sharing consent - existing permissions remain valid but new ones blocked'
          }),
        });
        break;

      case 'MARKETING':
        // Stop all marketing communications
        await this.auditService.log({
          userId,
          userRole: 'TALENT',
          action: 'MARKETING_STOPPED',
          resource: 'USER_PREFERENCES',
          resourceId: userId,
          details: JSON.stringify({
            action: 'marketing_communications_stopped',
          }),
        });
        break;

      case 'COMMUNICATION':
        // Stop platform communications (except critical ones)
        await this.auditService.log({
          userId,
          userRole: 'TALENT',
          action: 'COMMUNICATION_RESTRICTED',
          resource: 'USER_PREFERENCES', 
          resourceId: userId,
          details: JSON.stringify({
            action: 'non_critical_communications_stopped',
          }),
        });
        break;
    }
  }

  /**
   * Get all user consents
   */
  async getUserConsents(userId: string) {
    const consents = await db
      .select()
      .from(userConsents)
      .where(eq(userConsents.userId, userId))
      .limit(1);

    if (consents.length === 0) {
      // Return default consents
      return {
        marketing: true,
        dataSharing: true,
        communication: true,
      };
    }

    return {
      marketing: consents[0].marketing,
      dataSharing: consents[0].dataSharing,
      communication: consents[0].communication,
    };
  }

  /**
   * Check if user has given specific consent
   */
  async hasConsent(userId: string, consentType: 'marketing' | 'dataSharing' | 'communication'): Promise<boolean> {
    const consents = await this.getUserConsents(userId);
    return consents[consentType] ?? true; // Default to true if not set
  }

  /**
   * Get consent text for a specific type
   */
  private getConsentText(consentType: string): string {
    const texts: Record<string, string> = {
      KVKK: 'KVKK Aydınlatma Metni kapsamında kişisel verilerimin işlenmesine onay veriyorum.',
      MARKETING: 'Pazarlama amaçlı e-posta ve SMS gönderilmesine onay veriyorum.',
      COMMUNICATION: 'Platform güncellemeleri ve iş fırsatları hakkında bilgilendirilmeye onay veriyorum.',
      DATA_SHARING: 'Profil bilgilerimin doğrulanmış ajanslarla paylaşılmasına onay veriyorum.',
    };

    return texts[consentType] || `${consentType} onayı`;
  }

  /**
   * Export user consent data
   */
  async exportUserConsentData(userId: string) {
    const consents = await this.getUserConsents(userId);
    
    const contactPerms = await db
      .select()
      .from(contactPermissions)
      .where(eq(contactPermissions.talentId, userId));

    return {
      userId,
      exportDate: new Date().toISOString(),
      consents: consents,
      consentHistory: [], // TODO: Get from consentLogs if needed
      contactPermissions: contactPerms,
      policies: Object.keys(consents).map(type => 
        this.getConsentWithdrawalPolicy(type)
      ),
    };
  }
}
